import asyncio
import os
from pathlib import Path
from typing import Dict

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CallbackQueryHandler, CommandHandler, ContextTypes

# Path to the log file generated by monitor_keywords.py
LOG_FILE = Path(os.getenv("FORWARD_LOG_FILE", "monitor_log.txt"))
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

class FileForwardBot:
    """Simple bot that watches a text file and forwards new lines to Telegram."""

    def __init__(self) -> None:
        if not BOT_TOKEN:
            raise RuntimeError("TELEGRAM_BOT_TOKEN environment variable is required")
        self.app = Application.builder().token(BOT_TOKEN).build()
        self.tasks: Dict[int, asyncio.Task] = {}

        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CallbackQueryHandler(self.button))

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a menu with buttons to control forwarding."""
        keyboard = [
            [InlineKeyboardButton("å¼€å§‹è½¬å‘", callback_data="start")],
            [InlineKeyboardButton("åœæ­¢è½¬å‘", callback_data="stop")],
        ]
        await update.message.reply_text(
            "ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®å¼€å§‹æˆ–åœæ­¢è¯»å–æ—¥å¿—æ–‡ä»¶å¹¶å‘é€æ¶ˆæ¯ã€‚",
            reply_markup=InlineKeyboardMarkup(keyboard),
        )

    async def button(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle button presses."""
        query = update.callback_query
        await query.answer()
        chat_id = query.message.chat.id

        if query.data == "start":
            if chat_id in self.tasks and not self.tasks[chat_id].done():
                await query.edit_message_text("ç›‘å¬å·²åœ¨è¿›è¡Œä¸­ã€‚")
                return
            task = context.application.create_task(self.forward_loop(chat_id))
            self.tasks[chat_id] = task
            await query.edit_message_text("ðŸ“¡ å·²å¼€å§‹ç›‘å¬æ–‡ä»¶ã€‚")
        elif query.data == "stop":
            task = self.tasks.pop(chat_id, None)
            if task:
                task.cancel()
                await query.edit_message_text("â›” å·²åœæ­¢ç›‘å¬ã€‚")
            else:
                await query.edit_message_text("æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„ç›‘å¬ä»»åŠ¡ã€‚")

    async def forward_loop(self, chat_id: int) -> None:
        """Continuously watch the log file and forward new lines to the given chat."""
        last_size = LOG_FILE.stat().st_size if LOG_FILE.exists() else 0
        while True:
            await asyncio.sleep(1)
            if not LOG_FILE.exists():
                continue
            current_size = LOG_FILE.stat().st_size
            if current_size < last_size:
                # file truncated
                last_size = 0
            if current_size > last_size:
                with LOG_FILE.open("r", encoding="utf-8") as f:
                    f.seek(last_size)
                    for line in f:
                        line = line.strip()
                        if not line:
                            continue
                        # send only the part after the last separator if present
                        parts = line.split("|", maxsplit=5)
                        message = parts[-1].strip()
                        try:
                            await self.app.bot.send_message(chat_id=chat_id, text=message)
                        except Exception:
                            pass
                last_size = current_size

    def run(self) -> None:
        self.app.run_polling()

if __name__ == "__main__":
    FileForwardBot().run()
