"""Forward lines from a log file to Telegram chats."""

import asyncio
import logging
import os
from pathlib import Path
from typing import Dict

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
)

# Path to the log file generated by ``monitor_keywords.py``
LOG_FILE = Path(os.getenv("FORWARD_LOG_FILE", "monitor_log.txt"))
BOT_TOKEN = "8297216972:AAEZEeWLxie6xc0Fqd1wNKWrkqB-iIshQ9o"

logger = logging.getLogger(__name__)

class FileForwardBot:
    """Simple bot that watches a text file and forwards new lines to Telegram."""

    def __init__(self) -> None:
        if not BOT_TOKEN:
            raise RuntimeError("TELEGRAM_BOT_TOKEN environment variable is required")
        self.app = Application.builder().token(BOT_TOKEN).build()
        self.tasks: Dict[int, asyncio.Task] = {}

        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CallbackQueryHandler(self.button))

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a menu with buttons to control forwarding."""
        keyboard = [
            [InlineKeyboardButton("开始转发", callback_data="start")],
            [InlineKeyboardButton("停止转发", callback_data="stop")],
        ]
        await update.message.reply_text(
            "使用下方按钮开始或停止读取日志文件并发送消息。",
            reply_markup=InlineKeyboardMarkup(keyboard),
        )

    async def button(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle button presses for starting or stopping forwarding."""
        query = update.callback_query
        await query.answer()
        chat_id = query.message.chat.id

        if query.data == "start":
            await self.start_forwarding(chat_id, query, context)
        elif query.data == "stop":
            await self.stop_forwarding(chat_id, query)

    async def start_forwarding(
        self,
        chat_id: int,
        query,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Start watching the log file for a chat."""
        if chat_id in self.tasks and not self.tasks[chat_id].done():
            await query.edit_message_text("监听已在进行中。")
            return

        task = context.application.create_task(self.forward_loop(chat_id))
        self.tasks[chat_id] = task
        await query.edit_message_text("📡 已开始监听文件。")

    async def stop_forwarding(self, chat_id: int, query) -> None:
        """Stop watching the log file for a chat."""
        task = self.tasks.pop(chat_id, None)
        if task:
            task.cancel()
            await query.edit_message_text("⛔ 已停止监听。")
        else:
            await query.edit_message_text("没有正在进行的监听任务。")

    async def forward_loop(self, chat_id: int) -> None:
        """Continuously watch the log file and forward new lines to the given chat."""
        last_size = LOG_FILE.stat().st_size if LOG_FILE.exists() else 0
        while True:
            await asyncio.sleep(1)
            if not LOG_FILE.exists():
                last_size = 0
                continue

            current_size = LOG_FILE.stat().st_size
            if current_size < last_size:
                # file truncated
                last_size = 0
                continue

            if current_size > last_size:
                with LOG_FILE.open("r", encoding="utf-8") as f:
                    f.seek(last_size)
                    for line in f:
                        line = line.strip()
                        if not line:
                            continue

                        # send only the part after the last separator if present
                        message = line.split("|", maxsplit=5)[-1].strip()
                        try:
                            await self.app.bot.send_message(chat_id=chat_id, text=message)
                        except Exception as exc:  # pragma: no cover - network errors
                            logger.debug("Failed to send message: %s", exc)
                last_size = current_size

    def run(self) -> None:
        self.app.run_polling()

if __name__ == "__main__":
    FileForwardBot().run()
