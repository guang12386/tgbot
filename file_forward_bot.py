import asyncio
import os
from pathlib import Path
from typing import Dict

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CallbackQueryHandler, CommandHandler, ContextTypes

# Path to the log file generated by monitor_keywords.py
LOG_FILE = Path(os.getenv("FORWARD_LOG_FILE", "monitor_log.txt"))
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

class FileForwardBot:
    """Simple bot that watches a text file and forwards new lines to Telegram."""

    def __init__(self) -> None:
        if not BOT_TOKEN:
            raise RuntimeError("TELEGRAM_BOT_TOKEN environment variable is required")
        self.app = Application.builder().token(BOT_TOKEN).build()
        self.tasks: Dict[int, asyncio.Task] = {}

        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CallbackQueryHandler(self.button))

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a menu with buttons to control forwarding."""
        keyboard = [
            [InlineKeyboardButton("开始转发", callback_data="start")],
            [InlineKeyboardButton("停止转发", callback_data="stop")],
        ]
        await update.message.reply_text(
            "使用下方按钮开始或停止读取日志文件并发送消息。",
            reply_markup=InlineKeyboardMarkup(keyboard),
        )

    async def button(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle button presses."""
        query = update.callback_query
        await query.answer()
        chat_id = query.message.chat.id

        if query.data == "start":
            if chat_id in self.tasks and not self.tasks[chat_id].done():
                await query.edit_message_text("监听已在进行中。")
                return
            task = context.application.create_task(self.forward_loop(chat_id))
            self.tasks[chat_id] = task
            await query.edit_message_text("📡 已开始监听文件。")
        elif query.data == "stop":
            task = self.tasks.pop(chat_id, None)
            if task:
                task.cancel()
                await query.edit_message_text("⛔ 已停止监听。")
            else:
                await query.edit_message_text("没有正在进行的监听任务。")

    async def forward_loop(self, chat_id: int) -> None:
        """Continuously watch the log file and forward new lines to the given chat."""
        last_size = LOG_FILE.stat().st_size if LOG_FILE.exists() else 0
        while True:
            await asyncio.sleep(1)
            if not LOG_FILE.exists():
                continue
            current_size = LOG_FILE.stat().st_size
            if current_size < last_size:
                # file truncated
                last_size = 0
            if current_size > last_size:
                with LOG_FILE.open("r", encoding="utf-8") as f:
                    f.seek(last_size)
                    for line in f:
                        line = line.strip()
                        if not line:
                            continue
                        # send only the part after the last separator if present
                        parts = line.split("|", maxsplit=5)
                        message = parts[-1].strip()
                        try:
                            await self.app.bot.send_message(chat_id=chat_id, text=message)
                        except Exception:
                            pass
                last_size = current_size

    def run(self) -> None:
        self.app.run_polling()

if __name__ == "__main__":
    FileForwardBot().run()
